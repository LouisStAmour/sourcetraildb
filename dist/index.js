"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var bindings_1 = tslib_1.__importDefault(require("bindings"));
/**
 * Struct that represents a single hierarchical element that is part of a symbol's name.
 *
 *  prefix: optional prefix used for unique identification and shown in tooltips
 *  name: name represented by this element
 *  postfix: optional prefix used for unique identification and shown in tooltips
 */
var NameElement = /** @class */ (function () {
    function NameElement() {
        var _a = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            _a[_i] = arguments[_i];
        }
        var prefix = _a[0], name = _a[1], postfix = _a[2];
        this.prefix = "";
        this.postfix = "";
        if (name === undefined) {
            this.name = prefix;
            this.prefix = "";
            this.postfix = "";
        }
        else {
            this.name = name || "";
            this.prefix = prefix || "";
            this.postfix = postfix || "";
        }
    }
    return NameElement;
}());
exports.NameElement = NameElement;
/**
 * Struct that represents an entire name of a symbol.
 *
 *  nameDelimiter: delimiter added between name elements
 *  nameElements: all name elements that make up the hierarchy
 */
var NameHierarchy = /** @class */ (function () {
    function NameHierarchy(nameDelimiter, nameElements) {
        this.nameDelimiter = nameDelimiter;
        this.nameElements = nameElements;
    }
    return NameHierarchy;
}());
exports.NameHierarchy = NameHierarchy;
/**
 * Enum providing all possible values for a symbol's definition kind.
 *
 * The DefinitionKind specifies "how" a symbol is defined.
 * When recording the definition of a symbol, you would usually also record an explicit definition kind.
 * However, you may also want to record symbols that are implicitly generated by the compiler. In this case you can
 * record an implicit definition kind for those symbols.
 * If you do not record any definition kind for a symbol, Sourcetrail will show it as "non-indexed".
 */
var DefinitionKind;
(function (DefinitionKind) {
    DefinitionKind[DefinitionKind["IMPLICIT"] = 1] = "IMPLICIT";
    DefinitionKind[DefinitionKind["EXPLICIT"] = 2] = "EXPLICIT";
})(DefinitionKind = exports.DefinitionKind || (exports.DefinitionKind = {}));
/**
 * Enum providing all possible values for kinds of symbols that can be recorded using the SourcetrailDBWriter interface.
 */
var SymbolKind;
(function (SymbolKind) {
    SymbolKind[SymbolKind["TYPE"] = 0] = "TYPE";
    SymbolKind[SymbolKind["BUILTIN_TYPE"] = 1] = "BUILTIN_TYPE";
    SymbolKind[SymbolKind["MODULE"] = 2] = "MODULE";
    SymbolKind[SymbolKind["NAMESPACE"] = 3] = "NAMESPACE";
    SymbolKind[SymbolKind["PACKAGE"] = 4] = "PACKAGE";
    SymbolKind[SymbolKind["STRUCT"] = 5] = "STRUCT";
    SymbolKind[SymbolKind["CLASS"] = 6] = "CLASS";
    SymbolKind[SymbolKind["INTERFACE"] = 7] = "INTERFACE";
    SymbolKind[SymbolKind["ANNOTATION"] = 8] = "ANNOTATION";
    SymbolKind[SymbolKind["GLOBAL_VARIABLE"] = 9] = "GLOBAL_VARIABLE";
    SymbolKind[SymbolKind["FIELD"] = 10] = "FIELD";
    SymbolKind[SymbolKind["FUNCTION"] = 11] = "FUNCTION";
    SymbolKind[SymbolKind["METHOD"] = 12] = "METHOD";
    SymbolKind[SymbolKind["ENUM"] = 13] = "ENUM";
    SymbolKind[SymbolKind["ENUM_CONSTANT"] = 14] = "ENUM_CONSTANT";
    SymbolKind[SymbolKind["TYPEDEF"] = 15] = "TYPEDEF";
    SymbolKind[SymbolKind["TEMPLATE_PARAMETER"] = 16] = "TEMPLATE_PARAMETER";
    SymbolKind[SymbolKind["TYPE_PARAMETER"] = 17] = "TYPE_PARAMETER";
    SymbolKind[SymbolKind["MACRO"] = 18] = "MACRO";
    SymbolKind[SymbolKind["UNION"] = 19] = "UNION";
})(SymbolKind = exports.SymbolKind || (exports.SymbolKind = {}));
/**
 * Enum providing all possible values for kinds of references that can be recorded using the SourcetrailDBWriter interface.
 */
var ReferenceKind;
(function (ReferenceKind) {
    ReferenceKind[ReferenceKind["TYPE_USAGE"] = 0] = "TYPE_USAGE";
    ReferenceKind[ReferenceKind["USAGE"] = 1] = "USAGE";
    ReferenceKind[ReferenceKind["CALL"] = 2] = "CALL";
    ReferenceKind[ReferenceKind["INHERITANCE"] = 3] = "INHERITANCE";
    ReferenceKind[ReferenceKind["OVERRIDE"] = 4] = "OVERRIDE";
    ReferenceKind[ReferenceKind["TEMPLATE_ARGUMENT"] = 5] = "TEMPLATE_ARGUMENT";
    ReferenceKind[ReferenceKind["TYPE_ARGUMENT"] = 6] = "TYPE_ARGUMENT";
    ReferenceKind[ReferenceKind["TEMPLATE_DEFAULT_ARGUMENT"] = 7] = "TEMPLATE_DEFAULT_ARGUMENT";
    ReferenceKind[ReferenceKind["TEMPLATE_SPECIALIZATION"] = 8] = "TEMPLATE_SPECIALIZATION";
    ReferenceKind[ReferenceKind["TEMPLATE_MEMBER_SPECIALIZATION"] = 9] = "TEMPLATE_MEMBER_SPECIALIZATION";
    ReferenceKind[ReferenceKind["INCLUDE"] = 10] = "INCLUDE";
    ReferenceKind[ReferenceKind["IMPORT"] = 11] = "IMPORT";
    ReferenceKind[ReferenceKind["MACRO_USAGE"] = 12] = "MACRO_USAGE";
    ReferenceKind[ReferenceKind["ANNOTATION_USAGE"] = 13] = "ANNOTATION_USAGE";
})(ReferenceKind = exports.ReferenceKind || (exports.ReferenceKind = {}));
/**
 * Struct that represents the location of a range of characters in a source file.
 *
 *  note: Line and column numbers start at 1 instead of 0!
 *  note: The SourceRange includes both, the start and the end column number.
 */
var SourceRange = /** @class */ (function () {
    function SourceRange(fileId, startLine, startColumn, endLine, endColumn) {
        this.fileId = fileId;
        this.startLine = startLine;
        this.startColumn = startColumn;
        this.endLine = endLine;
        this.endColumn = endColumn;
    }
    return SourceRange;
}());
exports.SourceRange = SourceRange;
var sdk = bindings_1.default("sourcetraildb");
exports.Writer = sdk.Writer;
//# sourceMappingURL=index.js.map